const lz4 = require('lz4');
const path = require('path');
const fs = require('fs');
const readline = require("readline")
const Buffer = require('buffer').Buffer

const inputDir = 'data';
const outputDir = 'src/generate/compressed_data';

if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir);

new Promise((resolve, reject) => fs.readdir(inputDir, (err, files) => err ? reject(err) : resolve(files)))
    .then(files => Promise.all(files.map(basename => new Promise((resolve, reject) => {
        const inputPath = path.join(inputDir, basename)
        const outputPath = path.join(outputDir, path.basename(basename, '.txt')) + '.lz4'

        const object = {};
        return new Promise((resolve, reject) => fs.stat(inputPath, (err, istats) => err ? reject(err) : fs.stat(outputPath, (err, ostats) => err ? resolve(true) : resolve(istats.mtime > ostats.mtime))))
            .then(outOfDate => outOfDate ? readline.createInterface({
                input: fs.createReadStream(inputPath, 'utf8')
            }).on('line', line => {
                const [key, ...value] = line.split(/\t|,/);
                object[key] = value;
            }).on('close', () => fs.writeFile(outputPath, lz4.encode(new Buffer.from(JSON.stringify(object))), err => err ? reject(err) : resolve(outputPath))) : resolve(outputPath));
    }))))
    .then(files => new Promise((resolve, reject) => {
        const lines = []
        lines.push(`/* Autogenerated file, do not modify! */`)
        lines.push(`import readIntoMap from "./readIntoMap"`)
        files.forEach(file => {
            const shortname = path.basename(file, '.lz4')
            const shortnameIn = '__' + shortname;
            lines.push(`const ${shortnameIn} = require('${'../generate/compressed_data/' + path.basename(file)}').default;`);
            lines.push(`export const ${shortname} = readIntoMap(${shortnameIn})`)
        })

        fs.writeFile('src/typescript/main.ts', lines.join('\n'), err => err ? reject(err) : resolve())
    })).catch(reason => { throw new Error(reason) })